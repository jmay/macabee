# Macabee::Contacts is ruby representation of Mac Address Book

class Macabee::Contacts
  attr_reader :ab, :xrefkey

  def initialize(opts = {})
    # Apple docs recommend using `addressBook`, not `sharedAddressBook`
    @ab = ABAddressBook.addressBook
    @xrefkey = opts[:xref] || 'ab'
  end

  def contact(ab_id)
    query = ABPerson.searchElementForProperty(KABUIDProperty,
                    label:nil, key:nil, value: ab_id,
                    comparison:KABEqual)
    if rec = ab.recordsMatchingSearchElement(query).first
      Macabee::Contact.new(rec, :macabee => self)
    end
  end

  def lookup_query(hash)
    conditions = []
    conditions << ABPerson.searchElementForProperty(KABFirstNameProperty,
                    label:nil, key:nil, value: hash[:firstname],
                    comparison:KABEqualCaseInsensitive)
    conditions << ABPerson.searchElementForProperty(KABLastNameProperty,
                    label:nil, key:nil, value: hash[:lastname],
                    comparison:KABEqualCaseInsensitive)
    if hash[:orgname]
      conditions << ABPerson.searchElementForProperty(KABOrganizationProperty,
                    label:nil, key:nil, value: hash[:orgname],
                    comparison:KABEqualCaseInsensitive)
    end

    query = ABSearchElement.searchElementForConjunction(KABSearchAnd, children: conditions)
    matches = ab.recordsMatchingSearchElement(query)
    if matches.count == 1
      rec = matches.first
      Macabee::Contact.new(rec, :macabee => self)
    else
      # return nothing if there are no matches, or many
      # TODO: figure out better multi-match handling; any reliable way to guess which one we want?
      nil
    end
  end

  def lookup(*args)
    case args.count
    when 2
      firstname, lastname = args
      orgname = nil
    when 1
      d = args.first
      firstname = d['name'] && d['name']['first']
      lastname = d['name'] && d['name']['last']
      orgname = d['org'] && d['org']['organization']
    end

    # must have at least one of these
    return nil if firstname.nil? && lastname.nil? && orgname.nil?

    match = lookup_query(:firstname => firstname, :lastname => lastname, :orgname => orgname)
    if !match && orgname
      # if this record specifies an organization, then
      # make a second attempt for a match, ignoring the organization
      match = lookup_query(:firstname => firstname, :lastname => lastname)
    end
    match
  end

  def group(ab_id)
    query = ABGroup.searchElementForProperty(KABUIDProperty,
                    label:nil, key:nil, value: ab_id,
                    comparison:KABEqual)
    if rec = ab.recordsMatchingSearchElement(query).first
      Macabee::Group.new(rec, :macabee => self)
    end
  end

  def group_lookup(name)
    query = ABGroup.searchElementForProperty(KABGroupNameProperty,
                    label:nil, key:nil, value: name,
                    comparison:KABEqual)
    if rec = ab.recordsMatchingSearchElement(query).first
      Macabee::Group.new(rec, :macabee => self)
    end
  end

  # suck all the contacts from local MacOSX Address Book into a single array
  def contacts
    @contacts ||= @ab.people.map {|abperson| Macabee::Contact.new(abperson, :macabee => self)}
  end

  def groups
    @ab.groups.map {|abgroup| Macabee::Group.new(abgroup, :macabee => self)}
  end

  def to_hash
    {
      'contacts' => contacts.map(&:to_hash),
      'groups' => groups.map(&:to_hash)
    }
  end

  # def contacts_indexed
  #   @contacts_indexed ||= contacts.each_with_object({}) do |contact, hash|
  #     hash[contact.uuid] = contact
  #   end
  # end

  def find(hash)
    abid = hash['xref'] && hash['xref'][xrefkey]
    rec = contact(abid)
    if rec.nil?
      rec = lookup(hash)
      # if this finds a match, then the local Address Book UUID has changed
    end
    rec
  end

  def group_find(hash)
    abid = hash['xref'] && hash['xref'][xrefkey]
    rec = group(abid)
    if rec.nil?
      rec = group_lookup(hash['name'])
      # if this finds a match, then the local Address Book UUID has changed
    end
    rec
  end

  def diff(hash)
    contact = find(hash)
    if contact.nil?
      # no existing record, so this is an add
      contact = blank_contact
      # construct a changeset against a blank person record
      # ignore the AB UID that is generated by the framework, since this is only a dry run and we
      # aren't actually creating the record here.
      changes = contact.compare(hash).reject{|x| x[1] == 'xref.ab'}
      [nil, changes]
    else
      changes = contact.compare(hash)
      changes = contact.compare(hash).reject{|x| x[1] == 'xref.ab'}
      if changes.any?
        [contact.uuid, changes]
      else
        nil
      end
    end
  end

  def diffs(contactlist, opts)
    contactlist.each_with_object({}) do |data, changes|
      external_uid = data['xref'][opts[:xref]]
      case data['xref'][xrefkey]
      when nil
        # Any record that doesn't have a local AB identifier has never been sychronized with this
        # AB database. Check to see if a matching record exists that we can coalesce with.
        if contact = lookup(data)
          # found one
          already_known = (contactlist - [contact]).find {|c| (c['xref'] && c['xref'][xrefkey]) == contact.uuid}
          if !already_known
            changeset = contact.reverse_compare(data)
            changes[external_uid] = changeset
          end
        end
        # If there's no record in AB, that's fine, when we are ready to do an update we will
        # treat that as an addition and create a new ABPerson. Nothing to emit here.

      when 'DELETED'
        # If the identifier says 'DELETED' then we don't want to look for it in AB; we might
        # want to retain locally-deleted entries in our source, but we don't want to try to
        # reconstitute them in AB.

      else # this looks like a record that we've already synchronized with
        contact = find(data)
        if !contact
          # That KABUIDProperty value no longer appears. Maybe the UIDs were rebuilt? (That can happen
          # when you resync with iCloud.) Look for a record with the same name.
          contact = lookup(data)
          # do I need to repeat the already-known check above?
        end

        if contact
          changeset = contact.reverse_compare(data)
          if changeset.any?
            # there have been changes
            changes[external_uid] = changeset
          end
          # if there are no changes, emit nothing for this record
        else
          # This contact does not appear in the target, assume it has been deleted.
          # Construct a changeset that will reflect that back onto the source data.
          changes[external_uid] = [
            [
              '~',
              'xref.ab',
              'DELETED',
              data['xref'][xrefkey]
            ]
          ]
        end
      end
    end
  end

  def group_diffs(grouplist, opts)
    grouplist.each_with_object({}) do |data, changes|
      external_uid = data['xref'][opts[:xref]]
      case data['xref'][xrefkey]
      when nil
        if group = group_lookup(data['name'])
          # found one
          already_known = (grouplist - [group]).find {|c| (c['xref'] && c['xref'][xrefkey]) == group.uuid}
          if !already_known
            changeset = group.reverse_compare(data)
            changes[external_uid] = changeset
          end
        end

      when 'DELETED'
        # If the identifier says 'DELETED' then we don't want to look for it in AB; we might
        # want to retain locally-deleted entries in our source, but we don't want to try to
        # reconstitute them in AB.

      else # this looks like a record that we've already synchronized with
        group = group_find(data)
        if !group
          group = group_lookup(data)
        end

        if group
          changeset = group.reverse_compare(data)
          if changeset.any?
            # there have been changes
            changes[external_uid] = changeset
          end
          # if there are no changes, emit nothing for this record
        else
          changes[external_uid] = [
            [
              '~',
              'xref.ab',
              'DELETED',
              data['xref'][xrefkey]
            ]
          ]
        end
      end
    end
  end

  def apply(hash)
    contact = find(hash)
    diffs = contact.compare(hash)
    contact.apply(diffs)
    contact
  end

  # persist any staged contact changes to the database
  def save!(additions = [])
    additions.each do |contact|
      @ab.addRecord(contact.person)
    end

    @ab.save
  end

  # collection of record changes describing AB data state that doesn't match the inbound source records
  def revise(contactlist, opts = {})
    foreign_xref = opts[:xref]
    if contactlist.select {|r| !r['xref'] || !r['xref'][foreign_xref]}.any?
      raise "At least one record is missing an xref.#{foreign_xref} value"
    end

    changes = diffs(contactlist, opts)
    if opts[:additions]
      # Find all the Address Book uids that have been assigned to contacts during the diff process above;
      # don't treat these records as new additions.
      ab_changes = changes.map {|k,v| v.select {|chg| chg[1] == 'xref.ab'}}.map(&:first).compact
      matched_ab_uids = ab_changes.map {|ary| ary[2]}

      newuids = contacts.map(&:uuid) - contactlist.map{|c| c['xref'] && c['xref'][xrefkey]} - matched_ab_uids

      # adds = additions(contactlist).reject {|k,v| matched_ab_uids.include?(k)}
      adds = contacts.select {|c| newuids.include?(c.to_hash['xref'][xrefkey])}

      {
        :changes => changes,
        :additions => adds.map(&:to_hash)
      }
    else
      changes
    end
  end

  # same as #revise, but for groups
  def revise_groups(grouplist, opts = {})
    foreign_xref = opts[:xref]
    if grouplist.select {|r| !r['xref'] || !r['xref'][foreign_xref]}.any?
      raise "At least one record is missing an xref.#{foreign_xref} value"
    end

    changes = group_diffs(grouplist, opts)
    if opts[:additions]
      ab_changes = changes.map {|k,v| v.select {|chg| chg[1] == 'xref.ab'}}.map(&:first).compact
      matched_ab_uids = ab_changes.map {|ary| ary[2]}

      newuids = groups.map(&:uuid) - grouplist.map{|c| c['xref'] && c['xref'][xrefkey]} - matched_ab_uids

      adds = groups.select {|c| newuids.include?(c.to_hash['xref'][xrefkey])}

      {
        :changes => changes,
        :additions => adds.map(&:to_hash)
      }
    else
      changes
    end
  end

  # create a new (empty) contact in this Address Book, should not be persisted until #save! is called
  def blank_contact
    person = ABPerson.new
    person.initWithAddressBook(@ab)
    Macabee::Contact.new(person, :macabee => self)
  end

  def create_group(groupname, contactlist = [])
    group = Macabee::Group.new(:name => groupname, :macabee => self)
    @ab.addRecord(group.ab_group)
    contactlist.each do |contact|
      group << contact
    end
    group
  end
end
