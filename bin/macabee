#!/usr/bin/env ruby

require 'rubygems'
require 'macabee'
require "json"

ab = Macabee::Contacts.new

command, *args = ARGV
arg = args.first

case command
when 'dump'
  jj ab.to_hash

when 'groups'
  jj ab.groups.map(&:to_hash)

when 'contacts'
  jj ab.contacts.map(&:to_hash)

when 'contact'
  if contact = ab.contact(arg)
    jj contact.to_hash
  else
    raise "No such person in Address Book '#{arg}'"
  end

when 'lookup'
  firstname, lastname = args
  if contact = ab.lookup(firstname, lastname)
    jj contact.to_hash
  else
    raise "No such person in Address Book '#{args}'"
  end

when 'group'
  if group = ab.group(arg)
    jj group.to_hash
  else
    raise "No such group in Address Book '#{arg}'"
  end

when 'members'
  if group = ab.group(arg)
    jj group.members.map {|p| p.to_hash}
  else
    raise "No such group in Address Book '#{arg}'"
  end


when 'compare'
  # given a JSON representation of one or more contacts,
  # find each contact in AB and compare the input vs. AB
  # generate a list of changesets (don't emit anything for unchanged records)

  data = JSON.load(File.open(arg))
  data = [data] if data.is_a?(Hash)

  diffs = data.map do |hash|
    ab.diff(hash)
  end.compact
  if diffs.any?
    jj diffs
    $stderr.puts "Found changes in #{diffs.count} out of #{data.count} records."
  else
    $stderr.puts "No changes in #{data.count} records."
  end


when 'update'
  # same as 'compare', except that the changes should be applied back to the record
  data = JSON.load(File.open(arg))
  case data
  when Hash
    contact = ab.apply(data)
    unless args.include?('nosave')
      ab.save!
      $stderr.puts "Saved #{contact}"
    end

  when Array
    data.each do |rec|
      begin
        contact = ab.apply(rec)
        unless args.include?('nosave')
          ab.save!
          $stderr.puts "Saved #{contact}"
        end
      rescue Exception => e
        $stderr.puts "Update failed: #{e.message}"
        $stderr.puts e.backtrace.map{|s| "\t#{s}"}
      end
    end

  else
    raise "Bad object #{data.class} in input"
  end


when 'apply'
  # input JSON is treated as output from the 'compare' stage above
  # assume that no local changes have occurred since the 'compare' was run, and apply these deltas
  changes = JSON.load(File.open(arg))
  additions = []
  changes.each do |uid, rule|
    # each record is a pair [id, instructions]
    # if id is not-nil, then instructions are an array of diffs
    # if id is nil, then instructions are a hash that represents an entire new record
    contact = uid ? ab.contact(uid) : ab.blank_contact
    additions << contact if !uid

    contact.apply(rule)
  end

  unless args.include?('nosave')
    ab.save!(additions)
    $stderr.puts "Saved: #{additions.count} new contacts, #{changes.count - additions.count} updates."
  end

when 'revise'
  jsonfile, hint = args

  # compare the contacts in the input JSON against what is currently in AB
  # generate instructions to update the input to reflect the AB state
  data = JSON.load(File.open(jsonfile))
  revisions = ab.revise(data, :additions => (hint == 'entire'))
  jj revisions


else
  raise "Unknown command '#{command}'"
end
